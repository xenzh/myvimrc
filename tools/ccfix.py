# This script fixes clang compilation databases generated by bear tool to:
# * have absolute file paths instead of relative
# * have paths to point to root repo folder instead of build folder
#
# This helps to spare the pain of keeping local build folder just for clangd
# and having it break centralized builds from time to time.
#
# I know it's poorly written, but it still works sometimes.

import argparse
from json import load, dump
from os import path, walk

# ---------------------------------------------------------------

def process_entry(entry):
    new_entry = {}
    if "/build64" in entry["directory"]:
        new_entry["directory"] = entry["directory"].replace("/build64", "")
        new_entry["file"] = entry["file"][entry["file"].find("/home"):]

        new_entry["arguments"] = []
        for a in entry["arguments"]:
            if a.startswith("..") and "/home" in a:
                new_entry["arguments"].append(a[a.find("/home"):])
            else:
                new_entry["arguments"].append(a)

    return new_entry


def process_db(original):
    modified = []
    for file_entry in original:
        modified.append(process_entry(file_entry))

    return modified


def do_fix(args):
    updated = []
    with open(args.input, "r") as cdb_file:
        cdb = load(cdb_file)
        updated = process_db(cdb)

    if len(updated) > 0:
        with open(args.output, "w") as cdb_file:
            dump(updated, cdb_file)


# ---------------------------------------------------------------


def get_repo_source_files(repo_dir):
    index = []
    toplevel = True
    for root, dirs, files in walk(repo_dir, topdown=True):
        if toplevel:
            dirs[:] = [d for d in dirs if d != ".git" and d != "refroot"]
            toplevel = False

        local = filter(lambda v: v.endswith(".cpp"), files)
        abspaths = map(lambda v: path.join(path.abspath(repo_dir), path.join(root, v)), local)
        index = index + list(abspaths)

    return index


def read_flags(flags_file_path):
    with open(flags_file_path, "r") as flags_file:
        lines = flags_file.readlines()
        flags = filter(lambda l: l.startswith("-I"), lines)
        flags.append("-std=gnu++14")
        return [x.strip() for x in flags]


def make_entry(root, source_file, flags):
    return {
        "file": source_file,
        "directory": path.abspath(root),
        "arguments": ['g++', '-o', source_file[:-3] + 'o'] + flags
    }


def do_gen(args):
    files = get_repo_source_files(args.root)
    flags = read_flags(args.flagsfile)

    cdb = []
    for f in files:
        cdb.append(make_entry(args.root, f, flags))

    with open(args.output, "w") as cdb_file:
        dump(cdb, cdb_file)


# ---------------------------------------------------------------


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest="cmd")

    fix_parser = subparsers.add_parser("fix")
    fix_parser.add_argument("input")
    fix_parser.add_argument("output")

    gen_parser = subparsers.add_parser("gen")
    gen_parser.add_argument("root")
    gen_parser.add_argument("flagsfile")
    gen_parser.add_argument("output")

    args = parser.parse_args()

    if args.cmd == "fix":
        do_fix(args)
    elif args.cmd == "gen":
        do_gen(args)
    else:
        exit(1)

if __name__ == "__main__":
    main()
